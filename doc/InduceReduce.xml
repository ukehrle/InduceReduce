<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE Book SYSTEM "gapdoc.dtd">

<Book Name="InduceReduce">

<TitlePage>
	<Title>The <Package>InduceReduce</Package> Package</Title>
	<Version>Version 1.0</Version>
	<Author>Jonathan Gruber
		<Email>gruber@mathematik.uni-kl.de</Email>
	</Author>

	    <Copyright> 
    <Index>License</Index>
    &copyright; 2018 by Jonathan Gruber<P/>
    The <Package>InduceReduce</Package> package is free software; 
    you can redistribute it and/or modify it under the terms of the 
    <URL Text="GNU General Public License">http://www.fsf.org/licenses/gpl.html</URL> 
    as published by the Free Software Foundation; either version 3 of the License, 
    or (at your option) any later version.
</Copyright>
<Acknowledgements>
    I would like to thank Gunter Malle both for teaching me the theory behind the algorithm which is implemented in the program and for suggesting to make it a &GAP; package.
</Acknowledgements>
</TitlePage>

<TableOfContents/>

<Body>
	<Chapter> <Heading>The <Package>InduceReduce</Package> package</Heading>
		<Section Label="sec:theory"> <Heading>Theory</Heading>
			The <Package>InduceReduce</Package> provides a function for 	computing the table of ordinary irreducible characters of a finite group <M>G</M> using an algorithm based on Brauer's theorem on induced characters (see the <URL><Link>https://en.wikipedia.org/wiki/Brauer%27s_theorem_on_induced_characters</Link> <LinkText>Wikipedia</LinkText></URL> article), which has been described by W. Unger in <Cite Key="Unger"/>. By Brauer's theorem, the ring <M> \mathbb{Z} \mathop{Irr}(G)</M> of generalized characters of <M>G</M> is generated by the induced characters <M>\mathop{Ind}_H^G(\lambda)</M>, where <M>H</M> runs over all elementary subgroups of <M>G</M> and <M>\lambda</M> runs over all irreducible characters of <M>H</M>. The algorithm runs over suitably chosen elementary subgroups of <M>G</M>, computes their irreducible characters and induces them to <M>G</M>. In the resulting lattice of generalized characters, it searches for an orthonormal basis by means of LLL lattice reduction. Once an orthonormal basis of size equal to the number of conjugacy classes of <M>G</M> is found, it is clear from character theory that the elements of this basis are up to sign the irreducible characters of <M>G</M>.
		</Section>

		<Section Label="program"> <Heading>Program</Heading>
			Unger's Algorithm is implemented in the function <Code>CharacterTableUnger</Code>.
			<ManSection>
				<Func Name="CharacterTableUnger" Arg="G [ , Opt ]"/>
				<Description>
					This  function computes the character table of a finite group using Unger's algorithm. The argument <Arg>G</Arg> must be a finite group, the argument <Arg>Opt</Arg> must be a record which sets some options for the algorithm (more details in Section <Ref Sect="options"/> below).
					<Example>
gap> G:=AlternatingGroup(6);;
gap> CharacterTableUnger(G);
CharacterTable( Alt( [ 1 .. 6 ] ) )
					</Example>
				</Description>
			</ManSection>
			
			<ManSection>
				<InfoClass Name="InfoCTUnger" />
				<Description>
					The infoclass <Code>InfoCTUnger</Code> makes the function <Code>CharacterTableUnger</Code> display information about the current state of the computation, which may be useful for computations with large groups. If <Code>InfoCTUnger</Code> is set to <Code>1</Code> then the function first displays the number of conjugacy classes of <Arg>G</Arg> and then shows for any elementary subgroup <Math>E=ZP</Math> whose characters are induced to <Arg>G</Arg> the order of <Math>Z</Math>, the order of <Math>P</Math> and the number of conjugacy classes of <Math>E</Math>. If <Code>InfoCTUnger</Code> is set to <Code>2</Code> then it additionally displays the orders of the conjugacy. Moreover, it shows after each LLL reduction the total number of irreducible characters found so far, the dimension of the character lattice and the determinant of the Gram matrix.
					<Example>
gap> G:=AlternatingGroup(6);;
gap> SetInfoLevel(InfoCTUnger,1);
gap> CharacterTableUnger(G);
#I  Induce/Restrict: group with 7 conjugacy classes.
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 5, 1, 5 ]
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 4, 1, 4 ]
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
CharacterTable( Alt( [ 1 .. 6 ] ) )

gap> SetInfoLevel(InfoCTUnger,2);
gap> CharacterTableUnger(G);
#I  Induce/Restrict: group with 7 conjugacy classes.
#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 5, 1, 5 ]
#I  Reduce: |Irr| = 1, dim = 4, det(G) = 43
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 4, 1, 4 ]
#I  Reduce: |Irr| = 1, dim = 6, det(G) = 8
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
#I  Reduce: |Irr| = 2, dim = 7, det(G) = 4
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
#I  Reduce: |Irr| = 7
CharacterTable( Alt( [ 1 .. 6 ] ) )
					</Example>
				</Description>
			</ManSection>
			<ManSection>
				<Var Name="CTUngerDefaultOptions" />
				<Description>
					The global variable <Code>CTUngerDefaultOptions</Code> contains a record with four components <Code>DoCyclicFirst</Code>, <Code>DoCyclicLast</Code>, <Code>LLLOffset</Code> and <Code>Delta</Code>, which specify the default options for the function <Code>CharacterTableUnger</Code>. The options can be changed manually by the user, for more details see Subsection <Ref Subsect="changingdefault"/> below. The initial values for the record components are as follows:
					<Example>
gap> CTUngerDefaultOptions;
rec( Delta := 3/4, DoCyclicFirst := false, DoCyclicLast := false, LLLOffset := 0 )
					</Example>
				</Description>
			</ManSection>
		</Section>

		<Section Label="options"> <Heading>Options</Heading>
			In this section, we explain the options for <Code>CharacterTableUnger</Code> using the optional second argument <Arg>Opt</Arg>, which should be a record with components <Code>DoCyclicFirst</Code>, <Code>DoCyclicLast</Code>, <Code>LLLOffset</Code> and <Code>Delta</Code>. You only need to specify those components of the record that you want to manually set to a certain value, the others will be assigned their default value by the program. Additional components of the record will be ignored. The intended use of the different components of <Arg>Opt</Arg> is as follows:
			<Subsection><Heading>DoCyclicFirst and DocyclicLast</Heading>
				The component <Code>Opt.DoCyclicFirst</Code> should be a boolean which is by default set to <Code>false</Code>. It tells the function <Code>CharacterTableUnger</Code> to first induce all irreducible characters of the cyclic subgroups and then proceed to do the same for the non-cyclic elementary subgroups. The option <Code>Opt.DoCyclicLast</Code> does the opposite, that is, it tells <Code>CharacterTableUnger</Code> to first induce the characters of the non-cyclic elementary subgroups and then proceed to induce the characters of the cyclic subgroups. The default value is also <Code>false</Code> Note that even when <Code>Opt.DoCyclicLast</Code> is <Code>true</Code>, it may happen that some cyclic group are used by the algorithm earlier than some non-cyclic elementary subgroups, but only when the group <Math>P</Math> in <Math>E=ZP</Math> is cyclic. When both <Code>Opt.DoCyclicFirst</Code> and <Code>Opt.DoCyclicLast</Code> are set to be <Code>true</Code> then the program still induces from cyclic groups first.
				<Example>
gap> CharacterTableUnger(G,rec( DoCyclicFirst:=true ));
#I  Induce/Restrict: group with 7 conjugacy classes.
#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
#I  Induce: from cyclic subgroups
#I  Reduce: |Irr| = 7
CharacterTable( Alt( [ 1 .. 6 ] ) )

gap> CharacterTableUnger(G,rec( DoCyclicLast:=true ));
#I  Induce/Restrict: group with 7 conjugacy classes.
#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 1, 5, 5 ]
#I  Reduce: |Irr| = 1, dim = 4, det(G) = 43
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 1, 8, 5 ]
#I  Reduce: |Irr| = 5, dim = 6, det(G) = 2
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 1, 9, 9 ]
#I  Reduce: |Irr| = 7
CharacterTable( Alt( [ 1 .. 6 ] ) )
				</Example>
			</Subsection>
			<Subsection> <Heading>LLLOffset</Heading>
				The component <Code>Opt.LLLOffset</Code> should be an integer telling the function <Code>CharacterTableUnger</Code> to not apply LLL reduction to the Gram matrix of the character lattice each time after the characters of some elementary subgroup have been induced. More precisely, the first LLL reduction will be carried out after the characters of the first <Code>Opt.LLLOffset</Code>elementary subgroups have been induced. When <Code>Opt.DoCyclicFirst</Code> is true then the first LLL reduction will be carried out after the characters of the cyclic groups and the first <Code>Opt.LLLOffset</Code> non-cyclic elementary groups have been induced. The default value for <Code>Opt.LLLOffset</Code> is <Code>0</Code>.
				<Example>
gap> CharacterTableUnger(G,rec( LLLOffset:=3 ));
#I  Induce/Restrict: group with 7 conjugacy classes.
#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 5, 1, 5 ]
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 4, 1, 4 ]
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
#I  Reduce: |Irr| = 2, dim = 7, det(G) = 4
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
#I  Reduce: |Irr| = 7
CharacterTable( Alt( [ 1 .. 6 ] ) )
				</Example>
			</Subsection>
			<Subsection> <Heading>Delta</Heading>
				The component <Code>Opt.Delta</Code> can be used to specify the parameter <M>\delta</M> for the LLL reduction, where <M>1/4&lt;\delta\leq 1</M>. The default value for <Code>Opt.Delta</Code> is <Code>3/4</Code> and <Code>Opt.Delta</Code> is ignored if it is not a rational with <Code>1/4&lt;Opt.Delta</Code> and <Code>Opt.Delta&lt;=1</Code>.
				<Example>
gap> SetInfoLevel(InfoCTUnger,2);
gap> G:=AlternatingGroup(6);;
gap> CharacterTableUnger(G,rec( Delta:=3/10 ));
#I  Induce/Restrict: group with 7 conjugacy classes.
#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 5, 1, 5 ]
#I  Reduce: |Irr| = 1, dim = 4, det(G) = 43
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 4, 1, 4 ]
#I  Reduce: |Irr| = 1, dim = 6, det(G) = 8
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
#I  Reduce: |Irr| = 2, dim = 7, det(G) = 4
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 3, 1, 3 ]
#I  Reduce: |Irr| = 5, dim = 7, det(G) = 1
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 1, 9, 9 ]
#I  Reduce: |Irr| = 7
CharacterTable( Alt( [ 1 .. 6 ] ) )

gap> CharacterTableUnger(G,rec( Delta:=3/10, DoCyclicLast:=true ));
#I  Induce/Restrict: group with 7 conjugacy classes.
#I  Induce/Restrict: orders of class reps: [ 1, 2, 3, 3, 4, 5, 5 ]
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 1, 5, 5 ]
#I  Reduce: |Irr| = 1, dim = 4, det(G) = 43
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 1, 9, 9 ]
#I  Reduce: |Irr| = 2, dim = 6, det(G) = 3
#I  Induce/Restrict: Trying [|Z|, |P|, k(E)] = [ 1, 8, 5 ]
#I  Reduce: |Irr| = 5, dim = 7, det(G) = 1
#I  Reduce: |Irr| = 7
CharacterTable( Alt( [ 1 .. 6 ] ) )
			</Example>
			</Subsection>
			<Subsection Label="changingdefault"> <Heading>Changing the default options</Heading>
				In cases where the character tables of several groups need to be computed using the same options, it may be useful to change the default options, which are specified in the record <Code>CTUngerDefaultOptions</Code>. This can be done by simply overwriting the the components of that record.
				<Example>
gap> CTUngerDefaultOptions;
rec( Delta := 3/4, DoCyclicFirst := false, DoCyclicLast := false, LLLOffset := 0 )
gap> CTUngerDefaultOptions.Delta:=1;;
gap> CTUngerDefaultOptions.DoCyclicLast:=true;;
gap> CTUngerDefaultOptions;
rec( Delta := 1, DoCyclicFirst := false, DoCyclicLast := true, LLLOffset := 0 )
				</Example>
			</Subsection>
		</Section>
	</Chapter>


	<Chapter> <Heading>Installing and Loading the <Package>InduceReduce</Package> Package</Heading>
		<Section Label="sec:installing"> <Heading>Installing the package</Heading>
			InduceReduce does not use external binaries and, therefore, works without restrictions on the type of the operating system.<Br/>

			There are two ways of installing a &GAP; package. If you have permission to add files to the installation of &GAP; on your system you may install <Package>InduceReduce</Package> into the `pkg' subdirectory of the &GAP; installation tree. Otherwise you may install <Package>InduceReduce</Package> in a private `pkg' directory (for details see <URL> <Link>https://www.gap-system.org/Manuals/doc/ref/chap76.html#X82473E4B8756C6CD</Link> <LinkText>76.1 Installing a &GAP; Package</LinkText> </URL> and <URL> <Link>https://www.gap-system.org/Manuals/doc/ref/chap9.html#X7A4973627A5DB27D</Link> <LinkText>9.2 &GAP; Root Directories</LinkText> </URL> in the reference manual).
		</Section>

		<Section> <Heading>Loading the package</Heading>
			Once you have installed the package as described in the previous section, you can load it in a &GAP; session using the command <Code>LoadPackage("InduceReduce")</Code>.
		</Section>
	</Chapter>
</Body>

<Bibliography Databases="InduceReduce" />
<TheIndex/>

</Book>
